function [CT, CQ, OmegaU, PitchAngle] = SteadyState(Blade, Airfoil, Drivetrain, Control, U, AirDensity)
% Initialise parameters
OmegaU = zeros(size(U));
PitchAngle = zeros(size(U));
CT = zeros(size(U));
CQ = zeros(size(U));

OmegaA = Control.Torque.SpeedA*2*pi/60;
OmegaB = Control.Torque.SpeedB*2*pi/60;
OmegaB2 = Control.Torque.SpeedB2*2*pi/60;
OmegaC = Control.Torque.SpeedC*2*pi/60;
Region = 'lin'; % 'lin' = linear control curve, 'square' = quadratic control curve, 'point' = single control point
Omega = [OmegaA, OmegaB];
Qc = [0, Control.Torque.OptGain*OmegaB^2]; % Torque set by controller
Qr = [0, 0]; % Torque generated by rotor
Beta = [Control.Pitch.Fine, Control.Pitch.Fine];
FirstOptimal = true;
Tolerance = 0.0005;

for i = 1:length(U)
    disp(['U = ', num2str(U(i))])
    
    if U(i) >= Control.WindSpeed.Cutin && U(i) <= Control.WindSpeed.Cutout
    
        % Update rotor torque curve points to new wind speed
        [~, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(1), (Omega(1)/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i));
        Qr(1) = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;
        [~, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), (Omega(2)/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i));
        Qr(2) = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;

        % Move test section along control curve until control and rotor torque
        % cross or until end of control curve is reached
        while (Omega(1) < OmegaC && Qc(2) < Qr(2))

            Omega(1) = Omega(2);
            Qc(1) = Qc(2);
            Qr(1) = Qr(2);

            % Determine control region
            if Omega(1) == OmegaB % Region 2
                Omega(2) = OmegaB2;
                Qc(2) = Control.Torque.OptGain*OmegaB2^2;
                Region = 'square';
            elseif Omega(1) == OmegaB2 % Region 2 1/2
                Omega(2) = OmegaC;
                Qc(2) = Control.Torque.Demanded;
                Region = 'lin';
            else % Region 3
                Region = 'point';
            end

            % Determine torque from rotor performance
            [~, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), (Omega(2)/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i));
            Qr(2) = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;
        end

        if strcmp(Region, 'lin') % Operation linear transition section of partial load control region
            Omega1 = Omega(1);
            Omega2 = Omega(2);
            Qr1 = Qr(1);
            Qr2 = Qr(2);
            x1 = Omega(1);
            y1 = Qc(1);
            x2 = Omega(2);
            y2 = Qc(2);
            success = false;

            for iter = 1:20
                % Find crossing point of control curve and rotor torque curve
                % http://www.ambrsoft.com/MathCalc/Line/TwoLinesIntersection/TwoLinesIntersection.htm
                x3 = Omega1;
                y3 = Qr1;
                x4 = Omega2;
                y4 = Qr2;

                OmegaCross = ((x2*y1-x1*y2)*(x4-x3)-(x4*y3-x3*y4)*(x2-x1))/...
                    ((x2-x1)*(y4-y3)-(x4-x3)*(y2-y1));
                QcCross = Qc(1) + (OmegaCross-Omega(1))*(Qc(2)-Qc(1))/(Omega(2)-Omega(1));
                % Determine torque from rotor performance
                [CTr, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), (OmegaCross/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i));
                QrCross = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;
                Diff = (QrCross - QcCross)/Control.Torque.Demanded;

                if abs(Diff) < Tolerance
                    success = true;
                    break
                end
                
                if Diff > 0 % Rotor torque at iterated crossing point lies above control curve
                   Omega1 = OmegaCross;
                   Qr1 = QrCross;
                else
                   Omega2 = OmegaCross;
                   Qr2 = QrCross;
                end
            end
            if ~success
                warning('Tolerance not met during iteration of rotor speed')
            end

            OmegaU(i) = OmegaCross/Drivetrain.Gearbox.Ratio;
            PitchAngle(i) = Control.Pitch.Fine;
            CQ(i) = CQr;
            CT(i) = CTr;

        elseif strcmp(Region, 'square') % Operation quadratic optimal section of partial load control region
            if FirstOptimal

                Omega1 = Omega(1);
                Omega2 = Omega(2);
                Qr1 = Qr(1);
                Qr2 = Qr(2);
                success = false;

                for iter = 1:20
                    % Find crossing point of control curve and rotor torque
                    % curve with abc-formula
                    aa = Control.Torque.OptGain;
                    bb = -(Qr2-Qr1)/(Omega2-Omega1);
                    cc = -((Omega2*Qr1-Omega1*Qr2)/(Omega2-Omega1));

                    OmegaCross = (-bb + sqrt(bb^2-4*aa*cc))/(2*aa);
                    QcCross = Control.Torque.OptGain*OmegaCross^2;
                    
                    % Determine torque from rotor performance
                    [CTr, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), (OmegaCross/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i));
                    QrCross = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;
                    Diff = (QrCross - QcCross)/Control.Torque.Demanded;

                    if abs(Diff) < Tolerance
                        success = true;
                        break
                    end
                    
                    if Diff > 0 % Rotor torque at iterated crossing point lies above control curve
                       Omega1 = OmegaCross;
                       Qr1 = QrCross;
                    else
                       Omega2 = OmegaCross;
                       Qr2 = QrCross;
                    end
                end
                if ~success
                    warning('Tolerance not met during iteration of rotor speed')
                end

                OmegaU(i) = OmegaCross/Drivetrain.Gearbox.Ratio;
                PitchAngle(i) = Control.Pitch.Fine;
                CQ(i) = CQr;
                CT(i) = CTr;

                FirstOptimal = false;
            else
                PitchAngle(i) = Control.Pitch.Fine;
                OmegaU(i) = OmegaU(i-1) * U(i) / U(i-1);
                CQ(i) = CQ(i-1);
                CT(i) = CT(i-1);
            end

        else % Operation in full load control region

            TSRFull = (OmegaC/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i);
            Omega(1) = OmegaC;

            % Pitch blade until the rotor torque drops below the demanded
            % torque
            while Qr(2) > Control.Torque.Demanded

                Qr(1) = Qr(2);
                Beta(1) = Beta(2);
                Beta(2) = Beta(1)+0.5;

                % Determine torque from rotor performance
                [~, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), TSRFull);
                Qr(2) = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;

            end

            OmegaU(i) = OmegaC/Drivetrain.Gearbox.Ratio;
            PitchAngle(i) = interp1(Qr, Beta, Control.Torque.Demanded);
            [CTr, CQr] = PerformanceCoefficients(Blade, Airfoil, PitchAngle(i), TSRFull);
            CQ(i) = CQr;
            CT(i) = CTr;

%{
            % This iteration is not robust: it may converge to
            % pitch-to-stall solutions
            TSRFull = (OmegaC/Drivetrain.Gearbox.Ratio)*Blade.Radius(end)/U(i);

            Beta(1) = Beta(2);
            Qr(1) = Qr(2);
            Beta(2) = Beta(1)+2;
            % Determine torque from rotor performance
            [~, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), TSRFull);
            Qr(2) = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;
            success = false;

            for iter = 1:20
                % Find crossing point of control curve and rotor torque curve
                % http://www.ambrsoft.com/MathCalc/Line/TwoLinesIntersection/TwoLinesIntersection.htm

                Beta(2) = interp1(Qr, Beta, Control.Torque.Demanded, 'linear', 'extrap');
                [CTr, CQr] = PerformanceCoefficients(Blade, Airfoil, Beta(2), TSRFull);
                Qr(2) = 0.5*CQr*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio;
                
                Diff = (Qr(2) - Control.Torque.Demanded)/Control.Torque.Demanded;
                if abs(Diff) < Tolerance
                    success = true;
                    break
                end
            end
            if ~success
                warning('Tolerance not met during iteration of pitch angle')
            end

            OmegaU(i) = OmegaC/Drivetrain.Gearbox.Ratio;
            PitchAngle(i) = Beta(2);
            CQ(i) = Control.Torque.Demanded/(0.5*AirDensity*U(i)^2*pi*Blade.Radius(end)^3*Drivetrain.Gearbox.Efficiency/Drivetrain.Gearbox.Ratio);
            CT(i) = CTr;
%}
        end
    end
end